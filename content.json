{"pages":[],"posts":[{"title":"Redis入门","text":"Redis 入门Redis为什么单线程还这么快？ 核心：redis是将所有数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（cpu上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案！ 五大数据类型redis-key、String、List、Set、Hash、Zset String （字符串）1234567891011121314151617181920命令：append（追加字符串，如果不存在添加）strlen（字符串长度）incrby key （自增+1）incrby key n（制定增量）# 字符串范围 rangegetrange key 0 3 (字符串截取)getrange key 0 -1 (全部字符串)# 替换setrange key 1 xx （替换指定位置开始的字符串）ttl key # 查看key过期时间setex （set with expire） # 设置过期时间setnx (set if not exist) # 不存在再设置（在分布式锁中常使用） key存在失败mset # 批量添加mget # 批量获取msetnx # 原子性操作，要么一起成功要么一起失败getset #先get再set 如果不存在返回（nil） 如果存在返回原来的值 list（列表）可以把list玩成栈、队列、阻塞队列 123456789101112lpush list &quot;&quot; # 添加单个lrange list 0 1 # 获取list 范围rpush list &quot;&quot; # 将一个或多个插入到列表尾部lpop list # 移除 list第一个元素rpop list # 移除list最后一个元素lindex list 1 # 通过下标获取元素llen list # 返回list 长度lrem list n xxx # 移除一个或多个xxxtrim list 1 2 #截断listrpoplpush list newlist #移除列表最后一个元素到新列表中lset list 0 xxx # 将列表中指定下标的值替换为另一个值，如果不存在列表报错，如果存在更新当前下标的值，如果不存在，则会报错linsert list after xx xxx #将某个具体的value插入到某个元素前面或后面 Set（集合）1234567891011sadd key &quot;&quot; # set集合添加元素smembers key # 查看指定set的所有值sismember key xxx # 判断一个元素在set集合中scard key # 获取set集合中个数srem key xxx # 移除set中指定元素srandmember key # 随机抽选一个元素spop key # 随机删除一个元素smove key1 key2 &quot;xxx&quot; # 将指定一个元素移动到另一个set中sdiff key1 key2 # 差集sinter key1 key2 # 交集 共同好友就可以这样实现sunion key1 key2 # 并集 Hash（哈希）map集合，key-map 1234567hset # 添加一个key-valuehget # 获取一个字段hmset # 添加多个字段hmget # 获取多个字段hgetall # 获取全部数据gdel # 删除指定元素 hash存储变更的数据，尤其是用户信息之类的，经常变动的信息！ hash更适合于对象的存储 Zset（有序集合）在set基础上，增加了一个值 12345678zadd key 1 xxx # 添加一个值zadd key 2 xxx 3 xxx #添加多个值zrange key 0 -1 # 获取所有zrangebyscore key -inf +inf #从最近到最大 升序排序zrangebyscore key -inf +inf withscores #显示全部以及附加值zrevrange key 0 -1 # 从大到小排序zcount key min max # 获取指定区间数量 案例思路: set排序存储班级成绩表,工资表排序! 普通消息，1，重要消息2 ,带权重进行判断! 排行榜应用实现,取Top N测试! 三种特殊类型geospatial（地理空间）、hyperloglogs、bitmaps geospatial（地理空间）朋友的定位，附件的人，打车距离计算 GEO 底层是Zset 123456789geoadd key 经度 纬度 地名 # 添加地理坐标geopos key 地名 # 获取指定的定位geodist key 地名 地名 单位 # 直线距离georadius key 经度 纬度 半径 单位 # 附件的位置georadius key 经度 纬度 半径 单位 withdist # 显示到中间距离的位置georadius key 经度 纬度 半径 单位 withcoord # 显示他人的定位信息georadius key 经度 纬度 半径 单位 withcoord count 数量 # 筛选出指定数量的结果geooradiusbymember key 地名 距离 单位 #找出位于指定元素周围的其他元素geohash key 地名 地名 # 将二维的经纬度转为一维字符串，如果俩字符串越接近，那么距离越近 hyperloglogs（基础统计）hyperloglogs 基础统计的算法 0.81%错误率 基数：不重复的元素 优点：占用内存是固定的 案列：网页浏览量 123pfadd key xx # 创建第一组元素pfcount key #统计key元素基础数量pfmerge newkey oldkey oldkey # 合并俩组key 并集 bitmaps（位存储）统计用户信息，活跃，不活跃！ 登录，未登录！打卡记录！ 俩个状态都可以使用！ 操作二进制进行记录 只有0和1 俩状态 123setbit key 索引 0或1 # 添加getbit key 索引 # 查看bitcount key # 统计 事务Redis事务本质: 一组命令的集合! -个事务中的所有命令都会被序列化,在事务执行过程的中,会按照顺序执行! 一次性、顺序性、排他性!执行一些列的命令! redis事务没有隔离级别概念！ Redis单条命令式保存原子性的,但是事务不保证原子性! redis的事务： 开启事务 命令入队 执行事务 12345multi #开始事务xxxxxxexec # 执行事务discard #放弃事务 编译异常：事务中所有命令都不会被执行，比如命令错误 运行时异常：如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常 监视事务（乐观锁）：如果监视的key在执行事务时候被改变，事务会执行失败 123456watch xxx # 加锁multixxxexecunwatch # 解锁","link":"/2021/04/08/2021-04-08-Redis%E5%85%A5%E9%97%A8/"},{"title":"Redis持久化","text":"RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,它恢复时是将快照文件直接读到内存里。 Redis会单独创建( fork ) -个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。整个过程中,主进程是不进行任何I0操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感,那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 触发机制 1、save的规则自动触发 2、执行flushall 3、退出redis 优点： 1、适合大规模的数据恢复！ 2、对数据的完整性不高！ 缺点： 1、需要一定时间的间隔！如果redis意外宏碁，最后一次修改的数据就没了 2、fork进程会占用内存空间","link":"/2021/04/12/redis/"}],"tags":[{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"RDB","slug":"RDB","link":"/tags/RDB/"},{"name":"AOF","slug":"AOF","link":"/tags/AOF/"}],"categories":[{"name":"redis","slug":"redis","link":"/categories/redis/"}]}