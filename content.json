{"pages":[],"posts":[{"title":"Redis发布订阅","text":"Redis发布订阅(pub/sub)是一种消息通信模式: 发送者(pub)发送消息,订阅者(sub)接收消息。微信、微博、关注系统! Redis客户端可以订阅任意数量的频道。 订阅/发布消息图: 下图展示了频道channel1，以及订阅这个频道的三个客户端- - client2 、client5 和client1之间的关系: 当有新消息通过PUBLISH命令发送给频道channel1时,这个消息就会被发送给订阅它的三个客户端: 命令 12subscribe 频道 # 订阅频道publish 频道 # 发布消息到频道 原理 Redis是使用C实现的,通过分析Redis 源码里的pubsub.c文件,了解发布和订阅机制的底层实现,籍此加深对Redis的理解。 Redis通过PUBLISH、SUBSCRIBE 和PSUBSCRIBE等命令实现发布和订阅功能。 通过SUBSCRIBE命令订阅某频道后, redis-server 里维护了一个字典,字典的键就是一个个频道! , 而字典的值则是一个链表,链表中保存了所有订阅这个channel的客户端。SUBSCRIBE 命令的关键,就是将客户端添加到给定channel的订阅链表中。 通过PUBLISH命令向订阅者发送消息, redis-server会使用给定的频道作为键,在它所维护的channel 字典中查找记录了订阅这个频道的所有客户端的链表,遍历这个链表。将消息发布给所有订阅者。 Pub/Sub从字面上理解就是发布( Publish )与订阅( Subscribe ) , 在Redis中,你可以设定对某- -个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后,所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统,比如普通的即时聊天,群聊等功能。 使用场景： 1、实时消息系统 2、实时聊天室 3、订阅、关注系统","link":"/2021/04/14/20210414-redis/"},{"title":"Redis持久化","text":"RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,它恢复时是将快照文件直接读到内存里。 Redis会单独创建( fork ) -个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。整个过程中,主进程是不进行任何I0操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感,那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 ==RDB 保存的是 xxx.rdb文件== 触发机制 1、save的规则自动触发 2、执行flushall 3、退出redis 优点： 1、适合大规模的数据恢复！ 2、对数据的完整性不高！ 缺点： 1、需要一定时间的间隔！如果redis意外宏碁，最后一次修改的数据就没了 2、fork进程会占用内存空间 AOFAOF（append only file） 将所有命令都记录下来，history，恢复的时候将所有命令执行一遍 以日志的形式来记录每个写操作,将Redis执行过的所有指令记录下来(读操作不记录) , 只许追加文件但不可以改写文件, redis启动之初会读取该文件重新构建数据,换言之, redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 Aof保存的是 xxx.aof文件 aof 文件有错误，redis是启动不起来的，需要使用redis-check-aof --fix 命令修复 优点： 1、每一次修改都同步，文件的完整性会更加好 2、每秒同步一次，可能会丢失一秒的数据 3、从不同步，效率最高的 缺点： 1、相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢 2、aof运行效率也要比rdb慢，所以redis默认的配置就是rdb持久化 扩展： 1、RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储2、AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, AOF命令以Redis协议追加保存每次写的操作到文件末尾, Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。3、只做缓存,如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化4、同时开启两种持久化方式 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?作者建议不要,因为RDB更适合用于备份数据库( AOF在不断变化不好备份) , 快速重启,而且AOF可能潜在的Bug ,留着作为一个万一的手段。 5、性能建议 因为RDB文件只用作后备用途,建议只在Slave.上持久化RDB文件,而且只要15分钟备份一次就够了,只保留save 900 1这条规则。 如果Enable AOF , 好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了,代价一是带来 了持续的I0 ,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少AOF rewrite的频率, AOF重写的基础大小默认值64M太小了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF , 仅靠Master-Slave Repllcation实现高可用性也可以,能省掉一大笔I0 ,也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉,会丢失十几分钟的数据,启动脚本也要比较两个Master/Slave中的RDB文件,载入较新的那个,微博就是这种架构。","link":"/2021/04/12/redis/"},{"title":"Redis入门","text":"Redis 入门Redis为什么单线程还这么快？ 核心：redis是将所有数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（cpu上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案！ 五大数据类型redis-key、String、List、Set、Hash、Zset String （字符串）1234567891011121314151617181920命令：append（追加字符串，如果不存在添加）strlen（字符串长度）incrby key （自增+1）incrby key n（制定增量）# 字符串范围 rangegetrange key 0 3 (字符串截取)getrange key 0 -1 (全部字符串)# 替换setrange key 1 xx （替换指定位置开始的字符串）ttl key # 查看key过期时间setex （set with expire） # 设置过期时间setnx (set if not exist) # 不存在再设置（在分布式锁中常使用） key存在失败mset # 批量添加mget # 批量获取msetnx # 原子性操作，要么一起成功要么一起失败getset #先get再set 如果不存在返回（nil） 如果存在返回原来的值 list（列表）可以把list玩成栈、队列、阻塞队列 123456789101112lpush list &quot;&quot; # 添加单个lrange list 0 1 # 获取list 范围rpush list &quot;&quot; # 将一个或多个插入到列表尾部lpop list # 移除 list第一个元素rpop list # 移除list最后一个元素lindex list 1 # 通过下标获取元素llen list # 返回list 长度lrem list n xxx # 移除一个或多个xxxtrim list 1 2 #截断listrpoplpush list newlist #移除列表最后一个元素到新列表中lset list 0 xxx # 将列表中指定下标的值替换为另一个值，如果不存在列表报错，如果存在更新当前下标的值，如果不存在，则会报错linsert list after xx xxx #将某个具体的value插入到某个元素前面或后面 Set（集合）1234567891011sadd key &quot;&quot; # set集合添加元素smembers key # 查看指定set的所有值sismember key xxx # 判断一个元素在set集合中scard key # 获取set集合中个数srem key xxx # 移除set中指定元素srandmember key # 随机抽选一个元素spop key # 随机删除一个元素smove key1 key2 &quot;xxx&quot; # 将指定一个元素移动到另一个set中sdiff key1 key2 # 差集sinter key1 key2 # 交集 共同好友就可以这样实现sunion key1 key2 # 并集 Hash（哈希）map集合，key-map 1234567hset # 添加一个key-valuehget # 获取一个字段hmset # 添加多个字段hmget # 获取多个字段hgetall # 获取全部数据gdel # 删除指定元素 hash存储变更的数据，尤其是用户信息之类的，经常变动的信息！ hash更适合于对象的存储 Zset（有序集合）在set基础上，增加了一个值 12345678zadd key 1 xxx # 添加一个值zadd key 2 xxx 3 xxx #添加多个值zrange key 0 -1 # 获取所有zrangebyscore key -inf +inf #从最近到最大 升序排序zrangebyscore key -inf +inf withscores #显示全部以及附加值zrevrange key 0 -1 # 从大到小排序zcount key min max # 获取指定区间数量 案例思路: set排序存储班级成绩表,工资表排序! 普通消息，1，重要消息2 ,带权重进行判断! 排行榜应用实现,取Top N测试! 三种特殊类型geospatial（地理空间）、hyperloglogs、bitmaps geospatial（地理空间）朋友的定位，附件的人，打车距离计算 GEO 底层是Zset 123456789geoadd key 经度 纬度 地名 # 添加地理坐标geopos key 地名 # 获取指定的定位geodist key 地名 地名 单位 # 直线距离georadius key 经度 纬度 半径 单位 # 附件的位置georadius key 经度 纬度 半径 单位 withdist # 显示到中间距离的位置georadius key 经度 纬度 半径 单位 withcoord # 显示他人的定位信息georadius key 经度 纬度 半径 单位 withcoord count 数量 # 筛选出指定数量的结果geooradiusbymember key 地名 距离 单位 #找出位于指定元素周围的其他元素geohash key 地名 地名 # 将二维的经纬度转为一维字符串，如果俩字符串越接近，那么距离越近 hyperloglogs（基础统计）hyperloglogs 基础统计的算法 0.81%错误率 基数：不重复的元素 优点：占用内存是固定的 案列：网页浏览量 123pfadd key xx # 创建第一组元素pfcount key #统计key元素基础数量pfmerge newkey oldkey oldkey # 合并俩组key 并集 bitmaps（位存储）统计用户信息，活跃，不活跃！ 登录，未登录！打卡记录！ 俩个状态都可以使用！ 操作二进制进行记录 只有0和1 俩状态 123setbit key 索引 0或1 # 添加getbit key 索引 # 查看bitcount key # 统计 事务Redis事务本质: 一组命令的集合! -个事务中的所有命令都会被序列化,在事务执行过程的中,会按照顺序执行! 一次性、顺序性、排他性!执行一些列的命令! redis事务没有隔离级别概念！ Redis单条命令式保存原子性的,但是事务不保证原子性! redis的事务： 开启事务 命令入队 执行事务 12345multi #开始事务xxxxxxexec # 执行事务discard #放弃事务 编译异常：事务中所有命令都不会被执行，比如命令错误 运行时异常：如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常 监视事务（乐观锁）：如果监视的key在执行事务时候被改变，事务会执行失败 123456watch xxx # 加锁multixxxexecunwatch # 解锁","link":"/2021/04/08/2021-04-08-Redis%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"RDB","slug":"RDB","link":"/tags/RDB/"},{"name":"AOF","slug":"AOF","link":"/tags/AOF/"}],"categories":[{"name":"redis","slug":"redis","link":"/categories/redis/"}]}