{"pages":[],"posts":[{"title":"Redis入门","text":"Redis 入门Redis为什么单线程还这么快？ 核心：redis是将所有数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（cpu上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案！ 五大数据类型redis-key、String、List、Set、Hash、Zset String （字符串）1234567891011121314151617181920命令：append（追加字符串，如果不存在添加）strlen（字符串长度）incrby key （自增+1）incrby key n（制定增量）# 字符串范围 rangegetrange key 0 3 (字符串截取)getrange key 0 -1 (全部字符串)# 替换setrange key 1 xx （替换指定位置开始的字符串）ttl key # 查看key过期时间setex （set with expire） # 设置过期时间setnx (set if not exist) # 不存在再设置（在分布式锁中常使用） key存在失败mset # 批量添加mget # 批量获取msetnx # 原子性操作，要么一起成功要么一起失败getset #先get再set 如果不存在返回（nil） 如果存在返回原来的值 list（列表）可以把list玩成栈、队列、阻塞队列 123456789101112lpush list &quot;&quot; # 添加单个lrange list 0 1 # 获取list 范围rpush list &quot;&quot; # 将一个或多个插入到列表尾部lpop list # 移除 list第一个元素rpop list # 移除list最后一个元素lindex list 1 # 通过下标获取元素llen list # 返回list 长度lrem list n xxx # 移除一个或多个xxxtrim list 1 2 #截断listrpoplpush list newlist #移除列表最后一个元素到新列表中lset list 0 xxx # 将列表中指定下标的值替换为另一个值，如果不存在列表报错，如果存在更新当前下标的值，如果不存在，则会报错linsert list after xx xxx #将某个具体的value插入到某个元素前面或后面 Set（集合）1234567891011sadd key &quot;&quot; # set集合添加元素smembers key # 查看指定set的所有值sismember key xxx # 判断一个元素在set集合中scard key # 获取set集合中个数srem key xxx # 移除set中指定元素srandmember key # 随机抽选一个元素spop key # 随机删除一个元素smove key1 key2 &quot;xxx&quot; # 将指定一个元素移动到另一个set中sdiff key1 key2 # 差集sinter key1 key2 # 交集 共同好友就可以这样实现sunion key1 key2 # 并集 Hash（哈希）map集合，key-map 1234567hset # 添加一个key-valuehget # 获取一个字段hmset # 添加多个字段hmget # 获取多个字段hgetall # 获取全部数据gdel # 删除指定元素 hash存储变更的数据，尤其是用户信息之类的，经常变动的信息！ hash更适合于对象的存储 Zset（有序集合）在set基础上，增加了一个值 12345678zadd key 1 xxx # 添加一个值zadd key 2 xxx 3 xxx #添加多个值zrange key 0 -1 # 获取所有zrangebyscore key -inf +inf #从最近到最大 升序排序zrangebyscore key -inf +inf withscores #显示全部以及附加值zrevrange key 0 -1 # 从大到小排序zcount key min max # 获取指定区间数量 案例思路: set排序存储班级成绩表,工资表排序! 普通消息，1，重要消息2 ,带权重进行判断! 排行榜应用实现,取Top N测试! 三种特殊类型geospatial（地理空间）、hyperloglogs、bitmaps geospatial（地理空间）朋友的定位，附件的人，打车距离计算 GEO 底层是Zset 123456789geoadd key 经度 纬度 地名 # 添加地理坐标geopos key 地名 # 获取指定的定位geodist key 地名 地名 单位 # 直线距离georadius key 经度 纬度 半径 单位 # 附件的位置georadius key 经度 纬度 半径 单位 withdist # 显示到中间距离的位置georadius key 经度 纬度 半径 单位 withcoord # 显示他人的定位信息georadius key 经度 纬度 半径 单位 withcoord count 数量 # 筛选出指定数量的结果geooradiusbymember key 地名 距离 单位 #找出位于指定元素周围的其他元素geohash key 地名 地名 # 将二维的经纬度转为一维字符串，如果俩字符串越接近，那么距离越近 hyperloglogs（基础统计）hyperloglogs 基础统计的算法 0.81%错误率 基数：不重复的元素 优点：占用内存是固定的 案列：网页浏览量 123pfadd key xx # 创建第一组元素pfcount key #统计key元素基础数量pfmerge newkey oldkey oldkey # 合并俩组key 并集 bitmaps（位存储）统计用户信息，活跃，不活跃！ 登录，未登录！打卡记录！ 俩个状态都可以使用！ 操作二进制进行记录 只有0和1 俩状态 123setbit key 索引 0或1 # 添加getbit key 索引 # 查看bitcount key # 统计 事务Redis事务本质: 一组命令的集合! -个事务中的所有命令都会被序列化,在事务执行过程的中,会按照顺序执行! 一次性、顺序性、排他性!执行一些列的命令! redis事务没有隔离级别概念！ Redis单条命令式保存原子性的,但是事务不保证原子性! redis的事务： 开启事务 命令入队 执行事务 12345multi #开始事务xxxxxxexec # 执行事务discard #放弃事务 编译异常：事务中所有命令都不会被执行，比如命令错误 运行时异常：如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常 监视事务（乐观锁）：如果监视的key在执行事务时候被改变，事务会执行失败 123456watch xxx # 加锁multixxxexecunwatch # 解锁","link":"/2021/04/08/2021-04-08-Redis%E5%85%A5%E9%97%A8/"},{"title":"Redis发布订阅","text":"Redis发布订阅(pub/sub)是一种消息通信模式: 发送者(pub)发送消息,订阅者(sub)接收消息。微信、微博、关注系统! Redis客户端可以订阅任意数量的频道。 订阅/发布消息图: 下图展示了频道channel1，以及订阅这个频道的三个客户端- - client2 、client5 和client1之间的关系: 当有新消息通过PUBLISH命令发送给频道channel1时,这个消息就会被发送给订阅它的三个客户端: 命令 12subscribe 频道 # 订阅频道publish 频道 # 发布消息到频道 原理 Redis是使用C实现的,通过分析Redis 源码里的pubsub.c文件,了解发布和订阅机制的底层实现,籍此加深对Redis的理解。 Redis通过PUBLISH、SUBSCRIBE 和PSUBSCRIBE等命令实现发布和订阅功能。 通过SUBSCRIBE命令订阅某频道后, redis-server 里维护了一个字典,字典的键就是一个个频道! , 而字典的值则是一个链表,链表中保存了所有订阅这个channel的客户端。SUBSCRIBE 命令的关键,就是将客户端添加到给定channel的订阅链表中。 通过PUBLISH命令向订阅者发送消息, redis-server会使用给定的频道作为键,在它所维护的channel 字典中查找记录了订阅这个频道的所有客户端的链表,遍历这个链表。将消息发布给所有订阅者。 Pub/Sub从字面上理解就是发布( Publish )与订阅( Subscribe ) , 在Redis中,你可以设定对某- -个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后,所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统,比如普通的即时聊天,群聊等功能。 使用场景： 1、实时消息系统 2、实时聊天室 3、订阅、关注系统","link":"/2021/04/14/20210414-redis/"},{"title":"JVM探究","text":"JVM的位置 java运行环境JRE 包含了 JVM 操作系统之上是虚拟接（JVM） JVM的体系结构 java栈、本地方法栈、程序计数器 不会存在垃圾 一般垃圾存在于堆中 类加载器 作用：加载class文件 1、虚拟机自带加载器 2、启动类加载器 3、扩展类加载器 3、应用程序加载器 双亲委派机制 为了保障安全 app -》 ext -》 boot （最终执行根加载器） 1、类加载器收到类加载的请求 2、将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器 3、启动加载器检查是否能够加载当前这个类，能加载就使用当前加载器，否则抛出异常，通知子加载器进行加载 双亲委派模型的系统实现 在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。 12345678910111213141516171819202122protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve)throws ClassNotFoundException{ //check the class has been loaded or not Class c = findLoadedClass(name); if(c == null){ try{ if(parent != null){ c = parent.loadClass(name,false); }else{ c = findBootstrapClassOrNull(name); } }catch(ClassNotFoundException e){ //if throws the exception ,the father can not complete the load } if(c == null){ c = findClass(name); } } if(resolve){ resolveClass(c); } return c;} 沙箱安全机制 沙箱组成: 类加载器、字节码校验器 Native natice 关键字会调用c语言的库，会进入本地方法栈 PC寄存器 程序计数器: Program Counter Register 每个线程都有一个程序计数器，是线程私有的，就是一个指针, 指向方法区中的方法字节码(用来存储指向像 一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一条指令,是一一个非常小的内存空间，几乎可以忽略不计 方法区 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义, 简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间; 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存 中，和方法区无关 栈 三种JVM 堆 新生区、老年区 永久区 堆内存调优 GC","link":"/2021/04/21/20210421jvm/"},{"title":"Ubuntu安装nfs（服务端）","text":"win10 挂载NFS（网络文件夹） 安装NFS服务组件： 12sudo apt-get updatesudo apt-get install nfs-kernel-server 配置NFS： 1sudo nano /etc/exports 例如： 123#共享目录 /sync#允许的客户端网段（挂载选项）/sync 192.168.2.0/24(rw,sync,no_root_squash,no_subtree_check) 重启NFS服务： 1sudo systemctl restart nfs-server nano 操作命令 12345678910111213#符号(^)代表的是键盘的[Ctrl]按键#M代表的是键盘的[Alt]按键[ctrl]-G：取得联机帮助(help)，很有用的！[ctrl]-X：离开naon软件，若有修改过文件会提示是否需要储存喔！[ctrl]-O：储存文件，若你有权限的话就能够储存文件了；[ctrl]-R：从其他文件读入数据，可以将某个文件的内容贴在本文件中；[ctrl]-W：搜寻字符串，这个也是很有帮助的命令喔！[ctrl]-C：说明目前光标所在处的行数与列数等信息；[ctrl]-_：可以直接输入行号，让光标快速移动到该行；[alt]-Y：校正语法功能开启或关闭(单击开、再单击关)[alt]-M：可以支持鼠标来移动光标的功能# 如何保存（简单的保存流程，详细谷歌 nano编辑器）写完内容 -&gt; [ctrl]-O -&gt; 回车键 -&gt; [ctrl]-X","link":"/2021/04/21/Ubuntu-nfs/"},{"title":"Redis持久化","text":"RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,它恢复时是将快照文件直接读到内存里。 Redis会单独创建( fork ) -个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。整个过程中,主进程是不进行任何I0操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感,那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 ==RDB 保存的是 xxx.rdb文件== 触发机制 1、save的规则自动触发 2、执行flushall 3、退出redis 优点： 1、适合大规模的数据恢复！ 2、对数据的完整性不高！ 缺点： 1、需要一定时间的间隔！如果redis意外宏碁，最后一次修改的数据就没了 2、fork进程会占用内存空间 AOFAOF（append only file） 将所有命令都记录下来，history，恢复的时候将所有命令执行一遍 以日志的形式来记录每个写操作,将Redis执行过的所有指令记录下来(读操作不记录) , 只许追加文件但不可以改写文件, redis启动之初会读取该文件重新构建数据,换言之, redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 Aof保存的是 xxx.aof文件 aof 文件有错误，redis是启动不起来的，需要使用redis-check-aof --fix 命令修复 优点： 1、每一次修改都同步，文件的完整性会更加好 2、每秒同步一次，可能会丢失一秒的数据 3、从不同步，效率最高的 缺点： 1、相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢 2、aof运行效率也要比rdb慢，所以redis默认的配置就是rdb持久化 扩展： 1、RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储2、AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, AOF命令以Redis协议追加保存每次写的操作到文件末尾, Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。3、只做缓存,如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化4、同时开启两种持久化方式 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?作者建议不要,因为RDB更适合用于备份数据库( AOF在不断变化不好备份) , 快速重启,而且AOF可能潜在的Bug ,留着作为一个万一的手段。 5、性能建议 因为RDB文件只用作后备用途,建议只在Slave.上持久化RDB文件,而且只要15分钟备份一次就够了,只保留save 900 1这条规则。 如果Enable AOF , 好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了,代价一是带来 了持续的I0 ,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少AOF rewrite的频率, AOF重写的基础大小默认值64M太小了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF , 仅靠Master-Slave Repllcation实现高可用性也可以,能省掉一大笔I0 ,也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉,会丢失十几分钟的数据,启动脚本也要比较两个Master/Slave中的RDB文件,载入较新的那个,微博就是这种架构。","link":"/2021/04/12/redis/"}],"tags":[{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"nfs Ubuntu","slug":"nfs-Ubuntu","link":"/tags/nfs-Ubuntu/"},{"name":"RDB","slug":"RDB","link":"/tags/RDB/"},{"name":"AOF","slug":"AOF","link":"/tags/AOF/"}],"categories":[{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/categories/Ubuntu/"}]}