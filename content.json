{"pages":[],"posts":[{"title":"Redis入门","text":"Redis 入门Redis为什么单线程还这么快？ 核心：redis是将所有数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（cpu上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案！ 五大数据类型redis-key、String、List、Set、Hash、Zset String （字符串）1234567891011121314151617181920命令：append（追加字符串，如果不存在添加）strlen（字符串长度）incrby key （自增+1）incrby key n（制定增量）# 字符串范围 rangegetrange key 0 3 (字符串截取)getrange key 0 -1 (全部字符串)# 替换setrange key 1 xx （替换指定位置开始的字符串）ttl key # 查看key过期时间setex （set with expire） # 设置过期时间setnx (set if not exist) # 不存在再设置（在分布式锁中常使用） key存在失败mset # 批量添加mget # 批量获取msetnx # 原子性操作，要么一起成功要么一起失败getset #先get再set 如果不存在返回（nil） 如果存在返回原来的值 list（列表）可以把list玩成栈、队列、阻塞队列 123456789101112lpush list &quot;&quot; # 添加单个lrange list 0 1 # 获取list 范围rpush list &quot;&quot; # 将一个或多个插入到列表尾部lpop list # 移除 list第一个元素rpop list # 移除list最后一个元素lindex list 1 # 通过下标获取元素llen list # 返回list 长度lrem list n xxx # 移除一个或多个xxxtrim list 1 2 #截断listrpoplpush list newlist #移除列表最后一个元素到新列表中lset list 0 xxx # 将列表中指定下标的值替换为另一个值，如果不存在列表报错，如果存在更新当前下标的值，如果不存在，则会报错linsert list after xx xxx #将某个具体的value插入到某个元素前面或后面 Set（集合）1234567891011sadd key &quot;&quot; # set集合添加元素smembers key # 查看指定set的所有值sismember key xxx # 判断一个元素在set集合中scard key # 获取set集合中个数srem key xxx # 移除set中指定元素srandmember key # 随机抽选一个元素spop key # 随机删除一个元素smove key1 key2 &quot;xxx&quot; # 将指定一个元素移动到另一个set中sdiff key1 key2 # 差集sinter key1 key2 # 交集 共同好友就可以这样实现sunion key1 key2 # 并集 Hash（哈希）map集合，key-map 1234567hset # 添加一个key-valuehget # 获取一个字段hmset # 添加多个字段hmget # 获取多个字段hgetall # 获取全部数据gdel # 删除指定元素 hash存储变更的数据，尤其是用户信息之类的，经常变动的信息！ hash更适合于对象的存储 Zset（有序集合）在set基础上，增加了一个值 12345678zadd key 1 xxx # 添加一个值zadd key 2 xxx 3 xxx #添加多个值zrange key 0 -1 # 获取所有zrangebyscore key -inf +inf #从最近到最大 升序排序zrangebyscore key -inf +inf withscores #显示全部以及附加值zrevrange key 0 -1 # 从大到小排序zcount key min max # 获取指定区间数量 案例思路: set排序存储班级成绩表,工资表排序! 普通消息，1，重要消息2 ,带权重进行判断! 排行榜应用实现,取Top N测试! 三种特殊类型geospatial（地理空间）、hyperloglogs、bitmaps geospatial（地理空间）朋友的定位，附件的人，打车距离计算 GEO 底层是Zset 123456789geoadd key 经度 纬度 地名 # 添加地理坐标geopos key 地名 # 获取指定的定位geodist key 地名 地名 单位 # 直线距离georadius key 经度 纬度 半径 单位 # 附件的位置georadius key 经度 纬度 半径 单位 withdist # 显示到中间距离的位置georadius key 经度 纬度 半径 单位 withcoord # 显示他人的定位信息georadius key 经度 纬度 半径 单位 withcoord count 数量 # 筛选出指定数量的结果geooradiusbymember key 地名 距离 单位 #找出位于指定元素周围的其他元素geohash key 地名 地名 # 将二维的经纬度转为一维字符串，如果俩字符串越接近，那么距离越近 hyperloglogs（基础统计）hyperloglogs 基础统计的算法 0.81%错误率 基数：不重复的元素 优点：占用内存是固定的 案列：网页浏览量 123pfadd key xx # 创建第一组元素pfcount key #统计key元素基础数量pfmerge newkey oldkey oldkey # 合并俩组key 并集 bitmaps（位存储）统计用户信息，活跃，不活跃！ 登录，未登录！打卡记录！ 俩个状态都可以使用！ 操作二进制进行记录 只有0和1 俩状态 123setbit key 索引 0或1 # 添加getbit key 索引 # 查看bitcount key # 统计 事务Redis事务本质: 一组命令的集合! -个事务中的所有命令都会被序列化,在事务执行过程的中,会按照顺序执行! 一次性、顺序性、排他性!执行一些列的命令! redis事务没有隔离级别概念！ Redis单条命令式保存原子性的,但是事务不保证原子性! redis的事务： 开启事务 命令入队 执行事务 12345multi #开始事务xxxxxxexec # 执行事务discard #放弃事务 编译异常：事务中所有命令都不会被执行，比如命令错误 运行时异常：如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常 监视事务（乐观锁）：如果监视的key在执行事务时候被改变，事务会执行失败 123456watch xxx # 加锁multixxxexecunwatch # 解锁","link":"/2021/04/08/2021-04-08-Redis%E5%85%A5%E9%97%A8/"},{"title":"Redis发布订阅","text":"Redis发布订阅(pub/sub)是一种消息通信模式: 发送者(pub)发送消息,订阅者(sub)接收消息。微信、微博、关注系统! Redis客户端可以订阅任意数量的频道。 订阅/发布消息图: 下图展示了频道channel1，以及订阅这个频道的三个客户端- - client2 、client5 和client1之间的关系: 当有新消息通过PUBLISH命令发送给频道channel1时,这个消息就会被发送给订阅它的三个客户端: 命令 12subscribe 频道 # 订阅频道publish 频道 # 发布消息到频道 原理 Redis是使用C实现的,通过分析Redis 源码里的pubsub.c文件,了解发布和订阅机制的底层实现,籍此加深对Redis的理解。 Redis通过PUBLISH、SUBSCRIBE 和PSUBSCRIBE等命令实现发布和订阅功能。 通过SUBSCRIBE命令订阅某频道后, redis-server 里维护了一个字典,字典的键就是一个个频道! , 而字典的值则是一个链表,链表中保存了所有订阅这个channel的客户端。SUBSCRIBE 命令的关键,就是将客户端添加到给定channel的订阅链表中。 通过PUBLISH命令向订阅者发送消息, redis-server会使用给定的频道作为键,在它所维护的channel 字典中查找记录了订阅这个频道的所有客户端的链表,遍历这个链表。将消息发布给所有订阅者。 Pub/Sub从字面上理解就是发布( Publish )与订阅( Subscribe ) , 在Redis中,你可以设定对某- -个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后,所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统,比如普通的即时聊天,群聊等功能。 使用场景： 1、实时消息系统 2、实时聊天室 3、订阅、关注系统","link":"/2021/04/14/20210414-redis/"},{"title":"JVM探究","text":"JVM的位置 java运行环境JRE 包含了 JVM 操作系统之上是虚拟接（JVM） JVM的体系结构 java栈、本地方法栈、程序计数器 不会存在垃圾 一般垃圾存在于堆中 类加载器 作用：加载class文件 1、虚拟机自带加载器 2、启动类加载器 3、扩展类加载器 3、应用程序加载器 双亲委派机制 为了保障安全 app -》 ext -》 boot （最终执行根加载器） 1、类加载器收到类加载的请求 2、将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器 3、启动加载器检查是否能够加载当前这个类，能加载就使用当前加载器，否则抛出异常，通知子加载器进行加载 双亲委派模型的系统实现 在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。 12345678910111213141516171819202122protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve)throws ClassNotFoundException{ //check the class has been loaded or not Class c = findLoadedClass(name); if(c == null){ try{ if(parent != null){ c = parent.loadClass(name,false); }else{ c = findBootstrapClassOrNull(name); } }catch(ClassNotFoundException e){ //if throws the exception ,the father can not complete the load } if(c == null){ c = findClass(name); } } if(resolve){ resolveClass(c); } return c;} 沙箱安全机制 沙箱组成: 类加载器、字节码校验器 Native natice 关键字会调用c语言的库，会进入本地方法栈 PC寄存器 程序计数器: Program Counter Register 每个线程都有一个程序计数器，是线程私有的，就是一个指针, 指向方法区中的方法字节码(用来存储指向像 一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一条指令,是一一个非常小的内存空间，几乎可以忽略不计 方法区 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义, 简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间; 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存 中，和方法区无关 栈 栈内存，主管程序的运行，生命周期和线程同步； 线程结束，栈内存也就释放，对于栈来说，不存在垃圾回收问题； 栈存放内容：8大基本面类型+对象引用+实例的方法； 栈运行原理：栈帧 对象实例化的过程在内存中：程序执行时，首先成员变量以及方法体进入方法区中，程序执行main（）方法时，main方法体会进入栈区中这一过程称为进栈（压栈），定义一个引用指向对象实例的变量，程序执行到new 创建对象时，就会在堆内存中开辟一块内存空间，用于存放实例对象，在后在new实例中取成员变量以及成员方法的地址值；对对象赋值时会先在栈中找到引用地址，根据引用地址找到new 对象实例进行赋值操作；当方法执行完之后会从栈中弹出； 三种JVM sun 公司的 hotspot BEA公司 JRockit 是Oracle 是世界上最快的jvm用于财务前端办公、军事指挥与控制和电信网络的需要 IBM公司 j9 VM 堆 一个jvm只有一个堆，堆内存的大小可以调节。 堆内存中细分为新生区、养老区、永久区。 GC垃圾回收，主要是在伊甸园区和养老区 新生区 类的诞生、使用、销毁； 伊甸园区所有的对象时在伊甸园区创建的；内存满了会进行轻GC 辛存者区（0、1） 老年区 会进行重GC FUll GC 永久区 常驻内存，用来存放JDK自身携带的Class对象，存储的是java运行时的一些环境。这个区不存在垃圾回收，关闭虚拟机就会释放 jdk1.6前：永久代，常量池实在方法区； jdk1.8: 永久代，慢慢的退化了，去永久代，常量池在堆中 jdk1.8后：无永久代， 常量池在元空间 逻辑上存在物理上不存在 堆内存调优 是用JProfiler 分析异常排查以及定位 GC GC的算法有哪些？标记清除算法，标记压缩，复制算法，引用计数器怎么用？ JVM的内存模型和分区-详细到每个区放什么?堆里面的分区有哪些? Eden, form, to,老年区，说说他们的特点! 轻GC和重GC分别在什么时候发生? 引用计数法：会有个计数器记录每个对象引用次数，没有被引用的对象会被清除； 复制算法：eden、from 、to 这三个区主要用的是复制算法，当一个对象经历15次GC都没死可以通过参数进入老年代； 好处：没有内存的碎片；坏处：浪费了内存空间，假设对象100%存活拷贝； 最佳使用场景：对象存活度较低的时候； 标记压缩清除算法： 缺点：俩次扫描严重浪费时间，会产生内存碎片 优点：不需要额外的空间 总结： 年轻代： 存活率低使用复制算法； 老年代： 存活率高使用标记清楚压缩算法混合实现","link":"/2021/04/21/20210421jvm/"},{"title":"JUC并发编程","text":"1、什么是JUCjava.util.concurrent 简称JUC 通常在并发编程中很有用 2、线程和进程java默认有2个线程：main、GC； java无法直接开启线程； Thread线程有 几个状态 123456NEW 新生RUNNABLE 运行BLOCKED 阻塞WAITING 无限期等待TIMED_WAITING 超时等待TERMINATED 终止 wait/sleep区别 1、来自不同的类 wait =&gt; Object sleep =&gt; Thread 2、关于锁的释放 wait：需要主动去释放锁 sleep：到时间就会继续执行 3、使用的范围 wait：只能在同步代码块中使用 sleep： 可以再任何地方使用 3、Lock锁 Synchronized和lock区别 1、Synchronized 内置的Java关键字 ，Lock 是一个Java类2、Synchronized 无法判断获取锁的状态, Lock可以判断是否获取到了锁3、Synchronized 会自动释放锁, lock必须要手动释放锁!如果不释放锁,死锁4、Synchronized 线程1 (获得锁,阻塞)、线程2(等待,傻傻的等) ; Lock锁就不-定会等待下去;5、Synchronized 可重入锁 ,可以中断的,非公平; Lock ,可重入锁,可以判断锁,非公平(可以自己设置) ;6、Synchronized 适合锁少量的代码同步问题 , Lock适合锁大量的同步代码! 4、生产者与消费者问题 防止虚假唤醒 if 替换为while lock锁优点 可以使用condition指定唤醒线程 5、集合类线程不安全 并发下ArrayList不安全？ 解决方案： 1、List list = new Vector&lt;&gt;(;2、List list = Collections. synchronizedL ist(new ArrayList&lt;&gt;();3、List list = new CopyonwriteArrayList&lt;&gt;(); Vector：底层采用Synchronized实现； CopyonwriteArrayList：底层采用lock锁实现，写入时复制； set 不安全 解决方案： Set set = Collections . synchronizedSet(new HashSet&lt;&gt;());Set set = new CopyOnwriteArraySet&lt;&gt;( ); hashSet底层是什么 底层是hashMap 6、常用辅助类CountDownLatch减法计数器 原理： CountDownLatch. countDown（）; // 数量-1countDownLatch.await（）; // 等待计数器归零,然后再向下执行每次有线程调用countDown()数量-1 ,假设计数器变为0 , countDownLatch.await()就会被唤醒,继续执行! CyclicBarrier加法计数器 原理： 每次调用 await（） 计数器加一，计数器达到数量主线程就会被唤醒 Semaphore信号量 原理： Semaphore. acquire()获得 ,假设如果已经满了, 等待,等待被释放为止!semaphore. releaseO;释放,会将当前的信号量释放+ 1 ,然后唤醒等待的线程! 7、读写锁独占锁(写锁) 次只能被一个线程占有共享锁(读锁) 多个线程可以同时 占有读-读 可以共存!读-写 不能共存!写-写 不能共存! 8、线程池线程池:三大方法、7大参数、4种拒绝策略 池化技术 程序的运行,本质:占用系统的资源!优化资源的使用! =&gt;池化技术线程池、连接池、内存池、对象./…. 创建、销毁。十分浪费资源池化技术:事先准备好一些资源，有人要用,就来我这里拿,用完之后还给我。线程池的好处:1、降低资源的消耗2、提高响应的速度3、方便管理。线程复用、可以控制最大并发数、管理线程 线程 三大方法： Executors.newsingleThreadExecutor();//单个线程Executors.newF ixedThreadPool(5); //创建一个固定的线程池的大小Executors.newCachedThreadPool(); //可伸缩的，遇强则强，遇弱则弱 七大参数 int corepoolsize, //核心线程池大小int maximumPoolsize, //最大核心线程池大小long keepAliveTime， //超时了没有人调用就会释放TimeUnit unit, //超时单位Block ingQueue workQueue， //阻塞队列ThreadF actory threadFactory, //线程工厂:创建线程的，一般不用动RejectedE xecuti onHandler handle //拒绝策略 四种拒绝策略 new ThreadPoolExecutor . AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异常new ThreadPoolExecutor . CallerRunsPolicy() //哪来的去哪里!new ThreadPoolExecutor. DiscardPolicy() //队列满了，丢掉任务，不会抛出异常!new ThreadPoolExecutor. DiscardoldestPolicy() //队列满了 ，尝试去和最早的竞争，也不会抛出异常! IO密集型，cpu密集型 最大线程到底该如何定义1、CPU密集型,几核，就是几,可以保持CPu的效率最高!2、I0密集型&gt;判断你程序中十分耗IO的线程程序15个大型任务io+分占用资源! JMMJMM :java内存模型，不存在的东西，概念！约定 JMM关于同步的规定：1、线程解锁前，必须把共享变量的值刷新回主内存2、线程加锁前，必须读取主内存的最新值到自己的工作内存3、加锁解锁是同一把锁 主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成： lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则： 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 VolatileVolatile是Java虚拟机提供轻量级的同步机制1、保证可见性：一个子线程在自己工作内存中修改变量并写回主内存，主内存在通知其他线程更新变量2、不保证原子性：前几步是线程不安全的；最后一步内存屏障保证JVM让最新的变量在所有线程可见3、禁止指令重排: 保证指令执行顺序 CASCAS compareAndSwap:比较并交换! CAS是cpu的并发原语 CAS :比较当前工作内存中的值和主内存中的值,如果这个值是期望的,那么则执行操作! 如果不是就一直循环!也就是自旋锁缺点:1、循环会耗时2、 一次性只能保证一个共享变量的原子性3、ABA问题 atomicinteger，为什么要用cas而不是synchronized？ synchronized： 加锁只允许一个线程去修改，并发下降 cas：由于自旋锁，保证了一致性也保证了并发性","link":"/2021/06/04/JUC-20210604/"},{"title":"Ubuntu安装nfs（服务端）","text":"win10 挂载NFS（网络文件夹） 安装NFS服务组件： 12sudo apt-get updatesudo apt-get install nfs-kernel-server 配置NFS： 1sudo nano /etc/exports 例如： 123#共享目录 /sync#允许的客户端网段（挂载选项）/sync 192.168.2.0/24(rw,sync,no_root_squash,no_subtree_check) 重启NFS服务： 1sudo systemctl restart nfs-server nano 操作命令 12345678910111213#符号(^)代表的是键盘的[Ctrl]按键#M代表的是键盘的[Alt]按键[ctrl]-G：取得联机帮助(help)，很有用的！[ctrl]-X：离开naon软件，若有修改过文件会提示是否需要储存喔！[ctrl]-O：储存文件，若你有权限的话就能够储存文件了；[ctrl]-R：从其他文件读入数据，可以将某个文件的内容贴在本文件中；[ctrl]-W：搜寻字符串，这个也是很有帮助的命令喔！[ctrl]-C：说明目前光标所在处的行数与列数等信息；[ctrl]-_：可以直接输入行号，让光标快速移动到该行；[alt]-Y：校正语法功能开启或关闭(单击开、再单击关)[alt]-M：可以支持鼠标来移动光标的功能# 如何保存（简单的保存流程，详细谷歌 nano编辑器）写完内容 -&gt; [ctrl]-O -&gt; 回车键 -&gt; [ctrl]-X","link":"/2021/04/21/Ubuntu-nfs/"},{"title":"JVM参数调优","text":"一个对象大小计算方式：每秒生产多少M对象： 调优原则：让垃圾对象不要对老年代尽量在年轻代清理； java虚拟机推荐配比：老年代=2 ，年轻代=1(伊甸园=8:幸存区0=1:幸存区1=1) 参数： -Xmn2G 年轻代设置为2个G -Xss","link":"/2021/06/17/jvm-20210617/"},{"title":"IDEA模板","text":"创建线程Abbreviation: forthreat10 Description: 创建10个线程 Template text: 123new Thread(() -&gt; { $END$},$VAR$).start(); 创建10个线程Abbreviation: forthreat10 Description: 创建10个线程 Template text: 12345for (int i = 0; i &lt; 10; i++) { new Thread(() -&gt; { $END$ }, String.valueOf(i)).start();} 可重入锁Abbreviation: trylock Description: 可重入锁 Template text: 12345678$VAR$.lock();try { $END$} catch (Exception e) { e.printStackTrace();} finally { $VAR$.unlock();} 日志Abbreviation: log Description: 日志 Template text: 1log.info(&quot;$END$&quot;); 线程睡5秒Abbreviation: tsleep Description: 线程睡5秒 Template text: 12345try { TimeUnit.SECONDS.sleep(5);} catch (InterruptedException e) { e.printStackTrace();} 异常处理finallyAbbreviation: tryfinally Description: 异常处理finally Template text: 1234567try { $END$} catch (Exception e) { e.printStackTrace();} finally {}","link":"/2021/07/02/idea-template/"},{"title":"Redis持久化","text":"RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,它恢复时是将快照文件直接读到内存里。 Redis会单独创建( fork ) -个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。整个过程中,主进程是不进行任何I0操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感,那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 ==RDB 保存的是 xxx.rdb文件== 触发机制 1、save的规则自动触发 2、执行flushall 3、退出redis 优点： 1、适合大规模的数据恢复！ 2、对数据的完整性不高！ 缺点： 1、需要一定时间的间隔！如果redis意外宏碁，最后一次修改的数据就没了 2、fork进程会占用内存空间 AOFAOF（append only file） 将所有命令都记录下来，history，恢复的时候将所有命令执行一遍 以日志的形式来记录每个写操作,将Redis执行过的所有指令记录下来(读操作不记录) , 只许追加文件但不可以改写文件, redis启动之初会读取该文件重新构建数据,换言之, redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 Aof保存的是 xxx.aof文件 aof 文件有错误，redis是启动不起来的，需要使用redis-check-aof --fix 命令修复 优点： 1、每一次修改都同步，文件的完整性会更加好 2、每秒同步一次，可能会丢失一秒的数据 3、从不同步，效率最高的 缺点： 1、相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢 2、aof运行效率也要比rdb慢，所以redis默认的配置就是rdb持久化 扩展： 1、RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储2、AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, AOF命令以Redis协议追加保存每次写的操作到文件末尾, Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。3、只做缓存,如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化4、同时开启两种持久化方式 在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?作者建议不要,因为RDB更适合用于备份数据库( AOF在不断变化不好备份) , 快速重启,而且AOF可能潜在的Bug ,留着作为一个万一的手段。 5、性能建议 因为RDB文件只用作后备用途,建议只在Slave.上持久化RDB文件,而且只要15分钟备份一次就够了,只保留save 900 1这条规则。 如果Enable AOF , 好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了,代价一是带来 了持续的I0 ,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少AOF rewrite的频率, AOF重写的基础大小默认值64M太小了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF , 仅靠Master-Slave Repllcation实现高可用性也可以,能省掉一大笔I0 ,也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉,会丢失十几分钟的数据,启动脚本也要比较两个Master/Slave中的RDB文件,载入较新的那个,微博就是这种架构。","link":"/2021/04/12/redis/"}],"tags":[{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"JUC","slug":"JUC","link":"/tags/JUC/"},{"name":"nfs Ubuntu","slug":"nfs-Ubuntu","link":"/tags/nfs-Ubuntu/"},{"name":"IDEA模板","slug":"IDEA模板","link":"/tags/IDEA%E6%A8%A1%E6%9D%BF/"},{"name":"RDB","slug":"RDB","link":"/tags/RDB/"},{"name":"AOF","slug":"AOF","link":"/tags/AOF/"}],"categories":[{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"JUC","slug":"JUC","link":"/categories/JUC/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/categories/Ubuntu/"},{"name":"IDEA模板","slug":"IDEA模板","link":"/categories/IDEA%E6%A8%A1%E6%9D%BF/"}]}