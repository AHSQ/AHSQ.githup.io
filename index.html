<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="https://ahsq.github.io/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ahsq.github.io/img/og_image.png"><meta property="article:author" content="HSQ"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ahsq.github.io"},"headline":"Hexo","image":["https://ahsq.github.io/img/og_image.png"],"author":{"@type":"Person","name":"HSQ"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5936870219195046" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item is-active" href="/">关于</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-02T08:46:37.000Z" title="2021-7-2 4:46:37 ├F10: PM┤">2021-07-02</time>发表</span><span class="level-item"><time dateTime="2021-07-02T08:46:34.826Z" title="2021-7-2 4:46:34 ├F10: PM┤">2021-07-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/IDEA%E6%A8%A1%E6%9D%BF/">IDEA模板</a></span><span class="level-item">1 分钟读完 (大约134个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/02/idea-template/">IDEA模板</a></h1><div class="content"><h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><p>Abbreviation: forthreat10</p>
<p>Description: 创建10个线程</p>
<p>Template text: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    $END$</span><br><span class="line">&#125;,$VAR$).start();</span><br></pre></td></tr></table></figure>

<h5 id="创建10个线程"><a href="#创建10个线程" class="headerlink" title="创建10个线程"></a>创建10个线程</h5><p>Abbreviation: forthreat10</p>
<p>Description: 创建10个线程</p>
<p>Template text: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        $END$</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h5><p>Abbreviation: trylock</p>
<p>Description: 可重入锁</p>
<p>Template text: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$VAR$.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $END$</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)  &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    $VAR$.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>Abbreviation: log</p>
<p>Description: 日志</p>
<p>Template text: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;$END$&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="线程睡5秒"><a href="#线程睡5秒" class="headerlink" title="线程睡5秒"></a>线程睡5秒</h5><p>Abbreviation: tsleep</p>
<p>Description: 线程睡5秒</p>
<p>Template text: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="异常处理finally"><a href="#异常处理finally" class="headerlink" title="异常处理finally"></a>异常处理finally</h5><p>Abbreviation: tryfinally</p>
<p>Description: 异常处理finally</p>
<p>Template text: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $END$</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-17T06:23:37.000Z" title="2021-6-17 2:23:37 ├F10: PM┤">2021-06-17</time>发表</span><span class="level-item"><time dateTime="2021-06-17T07:03:51.069Z" title="2021-6-17 3:03:51 ├F10: PM┤">2021-06-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/JVM/">JVM</a></span><span class="level-item">几秒读完 (大约95个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/17/jvm-20210617/">JVM参数调优</a></h1><div class="content"><h6 id="一个对象大小计算方式："><a href="#一个对象大小计算方式：" class="headerlink" title="一个对象大小计算方式："></a>一个对象大小计算方式：</h6><h6 id="每秒生产多少M对象："><a href="#每秒生产多少M对象：" class="headerlink" title="每秒生产多少M对象："></a>每秒生产多少M对象：</h6><p><img src="/../images/jvm-20210617/image-20210617144235133.png" alt="image-20210617144235133"></p>
<p><img src="/../images/jvm-20210617/image-20210617144314891.png" alt="image-20210617144314891"></p>
<h6 id="调优原则："><a href="#调优原则：" class="headerlink" title="调优原则："></a>调优原则：</h6><p>让垃圾对象不要对老年代尽量在年轻代清理；</p>
<p>java虚拟机推荐配比：老年代=2 ，年轻代=1(伊甸园=8:幸存区0=1:幸存区1=1)</p>
<p>参数：</p>
<p>-Xmn2G    年轻代设置为2个G</p>
<p>-Xss</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-04T06:06:37.000Z" title="2021-6-4 2:06:37 ├F10: PM┤">2021-06-04</time>发表</span><span class="level-item"><time dateTime="2021-06-24T11:58:51.971Z" title="2021-6-24 7:58:51 ├F10: PM┤">2021-06-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/JUC/">JUC</a></span><span class="level-item">16 分钟读完 (大约2463个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/04/JUC-20210604/">JUC并发编程</a></h1><div class="content"><h2 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h2><p><strong>j</strong>ava.<strong>u</strong>til.<strong>c</strong>oncurrent 简称JUC  通常在并发编程中很有用</p>
<h2 id="2、线程和进程"><a href="#2、线程和进程" class="headerlink" title="2、线程和进程"></a>2、线程和进程</h2><p>java默认有2个线程：main、GC；</p>
<p>java无法直接开启线程；</p>
<blockquote>
<p>Thread线程有 几个状态</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW 新生</span><br><span class="line">RUNNABLE 运行</span><br><span class="line">BLOCKED 阻塞</span><br><span class="line">WAITING 无限期等待</span><br><span class="line">TIMED_WAITING 超时等待</span><br><span class="line">TERMINATED 终止</span><br></pre></td></tr></table></figure>

<blockquote>
<p>wait/sleep区别</p>
</blockquote>
<p>1、来自不同的类</p>
<p>wait  =&gt; Object</p>
<p>sleep =&gt; Thread</p>
<p>2、关于锁的释放</p>
<p>wait：需要主动去释放锁</p>
<p>sleep：到时间就会继续执行</p>
<p>3、使用的范围</p>
<p>wait：只能在同步代码块中使用</p>
<p>sleep： 可以再任何地方使用</p>
<h2 id="3、Lock锁"><a href="#3、Lock锁" class="headerlink" title="3、Lock锁"></a>3、Lock锁</h2><blockquote>
<p>Synchronized和lock区别</p>
</blockquote>
<p>1、Synchronized 内置的Java关键字 ，Lock 是一个Java类<br>2、Synchronized 无法判断获取锁的状态, Lock可以判断是否获取到了锁<br>3、Synchronized 会自动释放锁, lock必须要手动释放锁!如果不释放锁,死锁<br>4、Synchronized 线程1 (获得锁,阻塞)、线程2(等待,傻傻的等) ; Lock锁就不-定会等待下去;<br>5、Synchronized 可重入锁 ,可以中断的,非公平; Lock ,可重入锁,可以判断锁,非公平(可以自己设置) ;<br>6、Synchronized 适合锁少量的代码同步问题 , Lock适合锁大量的同步代码!</p>
<h2 id="4、生产者与消费者问题"><a href="#4、生产者与消费者问题" class="headerlink" title="4、生产者与消费者问题"></a>4、生产者与消费者问题</h2><blockquote>
<p>防止虚假唤醒</p>
</blockquote>
<p>if 替换为while</p>
<blockquote>
<p>lock锁优点</p>
</blockquote>
<p>可以使用condition指定唤醒线程</p>
<h2 id="5、集合类线程不安全"><a href="#5、集合类线程不安全" class="headerlink" title="5、集合类线程不安全"></a>5、集合类线程不安全</h2><blockquote>
<p>并发下ArrayList不安全？</p>
</blockquote>
<p>解决方案：</p>
<p>1、List<String> list = new Vector&lt;&gt;(;<br>2、List<String> list = Collections. synchronizedL ist(new ArrayList&lt;&gt;();<br>3、List<String> list = new CopyonwriteArrayList&lt;&gt;();</p>
<p>Vector：底层采用Synchronized实现；</p>
<p>CopyonwriteArrayList：底层采用lock锁实现，写入时复制；</p>
<blockquote>
<p>set 不安全</p>
</blockquote>
<p> 解决方案：</p>
<p>Set<String> set = Collections . synchronizedSet(new HashSet&lt;&gt;());<br>Set<string> set = new CopyOnwriteArraySet&lt;&gt;( );</p>
<blockquote>
<p>hashSet底层是什么</p>
</blockquote>
<p>底层是hashMap</p>
<h2 id="6、常用辅助类"><a href="#6、常用辅助类" class="headerlink" title="6、常用辅助类"></a>6、常用辅助类</h2><p><strong>CountDownLatch</strong>减法计数器</p>
<p>原理：</p>
<p>CountDownLatch. countDown（）; // 数量-1<br>countDownLatch.await（）; // 等待计数器归零,然后再向下执行<br>每次有线程调用countDown()数量-1 ,假设计数器变为0 , countDownLatch.await()就会被唤醒,继续执行!</p>
<p><strong>CyclicBarrier</strong>加法计数器</p>
<p>原理：</p>
<p>每次调用 await（） 计数器加一，计数器达到数量主线程就会被唤醒</p>
<p><strong>Semaphore</strong>信号量</p>
<p>原理：</p>
<p>Semaphore. acquire()获得 ,假设如果已经满了, 等待,等待被释放为止!<br>semaphore. releaseO;释放,会将当前的信号量释放+ 1 ,然后唤醒等待的线程!</p>
<h2 id="7、读写锁"><a href="#7、读写锁" class="headerlink" title="7、读写锁"></a>7、读写锁</h2><p>独占锁(写锁)   次只能被一个线程占有<br>共享锁(读锁)   多个线程可以同时 占有<br>读-读 可以共存!<br>读-写 不能共存!<br>写-写 不能共存!</p>
<h2 id="8、线程池"><a href="#8、线程池" class="headerlink" title="8、线程池"></a>8、线程池</h2><p>线程池:三大方法、7大参数、4种拒绝策略</p>
<blockquote>
<p>池化技术</p>
</blockquote>
<p>程序的运行,本质:占用系统的资源!优化资源的使用! =&gt;池化技术<br>线程池、连接池、内存池、对象./…. 创建、销毁。十分浪费资源<br>池化技术:事先准备好一些资源，有人要用,就来我这里拿,用完之后还给我。<br>线程池的好处:<br>1、降低资源的消耗<br>2、提高响应的速度<br>3、方便管理。<br>线程复用、可以控制最大并发数、管理线程</p>
<blockquote>
<p>线程</p>
</blockquote>
<p>三大方法：</p>
<p>Executors.newsingleThreadExecutor();//单个线程<br>Executors.newF ixedThreadPool(5); //创建一个固定的线程池的大小<br>Executors.newCachedThreadPool(); //可伸缩的，遇强则强，遇弱则弱</p>
<blockquote>
<p>七大参数</p>
</blockquote>
<p>int corepoolsize, //核心线程池大小<br>int maximumPoolsize, //最大核心线程池大小<br>long keepAliveTime， //超时了没有人调用就会释放<br>TimeUnit unit, //超时单位<br>Block ingQueue<Runnable> workQueue， //阻塞队列<br>ThreadF actory threadFactory, //线程工厂:创建线程的，一般不用动<br>RejectedE xecuti onHandler handle //拒绝策略</p>
<blockquote>
<p> 四种拒绝策略</p>
</blockquote>
<p>new ThreadPoolExecutor . AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异常<br>new ThreadPoolExecutor . CallerRunsPolicy() //哪来的去哪里!<br>new ThreadPoolExecutor. DiscardPolicy() //队列满了，丢掉任务，不会抛出异常!<br>new ThreadPoolExecutor. DiscardoldestPolicy() //队列满了 ，尝试去和最早的竞争，也不会抛出异常!</p>
<blockquote>
<p>IO密集型，cpu密集型</p>
</blockquote>
<p>最大线程到底该如何定义<br>1、CPU密集型,几核，就是几,可以保持CPu的效率最高!<br>2、I0密集型&gt;判断你程序中十分耗IO的线程<br>程序<br>15个大型任务io+分占用资源!</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JMM :java内存模型，不存在的东西，概念！约定</p>
<p>JMM关于同步的规定：<br>1、线程解锁前，必须把共享变量的值刷新回主内存<br>2、线程加锁前，必须读取主内存的最新值到自己的工作内存<br>3、加锁解锁是同一把锁</p>
<p>主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<ul>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Volatile是Java虚拟机提供轻量级的同步机制<br>1、保证可见性：一个子线程在自己工作内存中修改变量并写回主内存，主内存在通知其他线程更新变量<br>2、不保证原子性：前几步是线程不安全的；最后一步内存屏障保证JVM让最新的变量在所有线程可见<br>3、禁止指令重排: 保证指令执行顺序</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS compareAndSwap:比较并交换!</p>
<p> CAS是cpu的并发原语</p>
<p>CAS :比较当前工作内存中的值和主内存中的值,如果这个值是期望的,那么则执行操作! 如果不是就一直循环!也就是自旋锁<br><strong>缺点:</strong><br>1、循环会耗时<br>2、 一次性只能保证一个共享变量的原子性<br>3、ABA问题</p>
<p><strong>atomicinteger，为什么要用cas而不是synchronized？</strong></p>
<p>synchronized： 加锁只允许一个线程去修改，并发下降</p>
<p>cas：由于自旋锁，保证了一致性也保证了并发性</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-21T11:06:37.000Z" title="2021-4-21 7:06:37 ├F10: PM┤">2021-04-21</time>发表</span><span class="level-item"><time dateTime="2021-06-16T07:16:16.514Z" title="2021-6-16 3:16:16 ├F10: PM┤">2021-06-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/JVM/">JVM</a></span><span class="level-item">11 分钟读完 (大约1596个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/21/20210421jvm/">JVM探究</a></h1><div class="content"><ol>
<li><p>JVM的位置</p>
</li>
<li><p> java运行环境JRE 包含了 JVM</p>
</li>
<li><p>操作系统之上是虚拟接（JVM）</p>
</li>
<li><p>JVM的体系结构</p>
</li>
</ol>
<p>  <img src="/../images/20210421jvm/image-20210421201908366.png" alt="image-20210421201908366"></p>
<ol>
<li><p>java栈、本地方法栈、程序计数器 不会存在垃圾</p>
</li>
<li><p>一般垃圾存在于堆中</p>
</li>
<li><p>类加载器</p>
</li>
</ol>
<p>  作用：加载class文件</p>
<p>  1、虚拟机自带加载器</p>
<p>  2、启动类加载器</p>
<p>  3、扩展类加载器</p>
<p>  3、应用程序加载器</p>
<ol start="4">
<li>双亲委派机制</li>
</ol>
<p>  为了保障安全</p>
<p>  app -》 ext -》 boot （最终执行根加载器）</p>
<p>  1、类加载器收到类加载的请求</p>
<p>  2、将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器</p>
<p>  3、启动加载器检查是否能够加载当前这个类，能加载就使用当前加载器，否则抛出异常，通知子加载器进行加载</p>
<p>  <strong>双亲委派模型的系统实现</strong></p>
<p>  在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name,<span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">//check the class has been loaded or not</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent != <span class="keyword">null</span>)&#123;</span><br><span class="line">                c = parent.loadClass(name,<span class="keyword">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            <span class="comment">//if throws the exception ,the father can not complete the load</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="keyword">null</span>)&#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resolve)&#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>沙箱安全机制</li>
</ol>
<p>  沙箱组成: 类加载器、字节码校验器</p>
<ol start="6">
<li>Native</li>
</ol>
<p>  natice 关键字会调用c语言的库，会进入本地方法栈</p>
<ol start="7">
<li>PC寄存器</li>
</ol>
<p>  程序计数器: Program Counter Register<br>  每个线程都有一个程序计数器，是线程私有的，就是一个指针, 指向方法区中的方法字节码(用来存储指向像<br>  一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一条指令,是一一个非常小的内存空间，几乎可以忽略不计</p>
<ol start="8">
<li>方法区</li>
</ol>
<p>  方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,<br>  简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间;<br>  静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存<br>  中，和方法区无关</p>
<ol start="9">
<li>栈</li>
</ol>
<p>栈内存，主管程序的运行，生命周期和线程同步；</p>
<p>线程结束，栈内存也就释放，对于栈来说，不存在垃圾回收问题；</p>
<p>栈存放内容：8大基本面类型+对象引用+实例的方法；</p>
<p>栈运行原理：栈帧</p>
<p>对象实例化的过程在内存中：程序执行时，首先成员变量以及方法体进入<code>方法区</code>中，程序执行main（）方法时，main方法体会进入栈区中这一过程称为进栈（压栈），定义一个引用指向对象实例的变量，程序执行到new 创建对象时，就会在堆内存中开辟一块内存空间，用于存放实例对象，在后在new实例中取成员变量以及成员方法的地址值；对对象赋值时会先在栈中找到引用地址，根据引用地址找到new 对象实例进行赋值操作；当方法执行完之后会从栈中弹出；</p>
<ol start="10">
<li><p>三种JVM</p>
<ul>
<li>sun 公司的 hotspot</li>
<li>BEA公司 JRockit 是Oracle  是世界上最快的jvm用于财务前端办公、军事指挥与控制和电信网络的需要</li>
<li>IBM公司 j9 VM</li>
</ul>
</li>
<li><p>堆</p>
<p>一个jvm只有一个堆，堆内存的大小可以调节。</p>
<p>堆内存中细分为新生区、养老区、永久区。</p>
<p><img src="/../images/20210421jvm/image-20210531201714725.png" alt="image-20210531201714725"></p>
<p>GC垃圾回收，主要是在伊甸园区和养老区</p>
</li>
<li><p>新生区</p>
<p>类的诞生、使用、销毁；</p>
<p>伊甸园区所有的对象时在伊甸园区创建的；内存满了会进行轻GC</p>
<p>辛存者区（0、1）</p>
</li>
<li><p>老年区</p>
<p>会进行重GC FUll GC</p>
</li>
<li><p>永久区</p>
<p>常驻内存，用来存放JDK自身携带的Class对象，存储的是java运行时的一些环境。这个区不存在垃圾回收，关闭虚拟机就会释放</p>
<p>jdk1.6前：永久代，常量池实在方法区；</p>
<p>jdk1.8:       永久代，慢慢的退化了，去永久代，常量池在堆中</p>
<p>jdk1.8后：无永久代， 常量池在元空间</p>
<p>逻辑上存在物理上不存在</p>
</li>
<li><p>堆内存调优</p>
<p>是用JProfiler 分析异常排查以及定位</p>
</li>
<li><p>GC</p>
<p>GC的算法有哪些？标记清除算法，标记压缩，复制算法，引用计数器怎么用？</p>
<p>JVM的内存模型和分区-详细到每个区放什么?<br>堆里面的分区有哪些? Eden, form, to,老年区，说说他们的特点!</p>
<p>轻GC和重GC分别在什么时候发生? </p>
<p><strong>引用计数法</strong>：会有个计数器记录每个对象引用次数，没有被引用的对象会被清除；</p>
<p><strong>复制算法</strong>：eden、from 、to  这三个区主要用的是复制算法，当一个对象经历15次GC都没死可以通过参数进入老年代；</p>
<p>好处：没有内存的碎片；坏处：浪费了内存空间，假设对象100%存活拷贝；</p>
<p>最佳使用场景：对象存活度较低的时候；</p>
<p><strong>标记压缩清除算法</strong>：</p>
<p><img src="/../images/20210421jvm/image-20210602192149047.png" alt="image-20210602192149047"></p>
<p>缺点：俩次扫描严重浪费时间，会产生内存碎片</p>
<p>优点：不需要额外的空间</p>
<p><strong>总结</strong>：</p>
<p>年轻代： 存活率低使用复制算法；</p>
<p>老年代： 存活率高使用标记清楚压缩算法混合实现</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-21T11:06:37.000Z" title="2021-4-21 7:06:37 ├F10: PM┤">2021-04-21</time>发表</span><span class="level-item"><time dateTime="2021-04-28T03:51:14.127Z" title="2021-4-28 11:51:14 ├F10: AM┤">2021-04-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Ubuntu/">Ubuntu</a></span><span class="level-item">2 分钟读完 (大约355个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/21/Ubuntu-nfs/">Ubuntu安装nfs（服务端）</a></h1><div class="content"><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34158598/article/details/81976063">win10 挂载NFS（网络文件夹）</a></p>
</blockquote>
<p><strong>安装NFS服务组件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure>

<p><strong>配置NFS：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/exports</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#共享目录 /sync</span></span><br><span class="line"><span class="comment">#允许的客户端网段（挂载选项）</span></span><br><span class="line">/sync 192.168.2.0/24(rw,sync,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure>

<p><strong>重启NFS服务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nfs-server</span><br></pre></td></tr></table></figure>

<p>nano 操作命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#符号(^)代表的是键盘的[Ctrl]按键</span></span><br><span class="line"><span class="comment">#M代表的是键盘的[Alt]按键</span></span><br><span class="line">[ctrl]-G：取得联机帮助(<span class="built_in">help</span>)，很有用的！</span><br><span class="line">[ctrl]-X：离开naon软件，若有修改过文件会提示是否需要储存喔！</span><br><span class="line">[ctrl]-O：储存文件，若你有权限的话就能够储存文件了；</span><br><span class="line">[ctrl]-R：从其他文件读入数据，可以将某个文件的内容贴在本文件中；</span><br><span class="line">[ctrl]-W：搜寻字符串，这个也是很有帮助的命令喔！</span><br><span class="line">[ctrl]-C：说明目前光标所在处的行数与列数等信息；</span><br><span class="line">[ctrl]-_：可以直接输入行号，让光标快速移动到该行；</span><br><span class="line">[alt]-Y：校正语法功能开启或关闭(单击开、再单击关)</span><br><span class="line">[alt]-M：可以支持鼠标来移动光标的功能</span><br><span class="line"><span class="comment"># 如何保存（简单的保存流程，详细谷歌 nano编辑器）</span></span><br><span class="line">写完内容 -&gt; [ctrl]-O -&gt; 回车键 -&gt; [ctrl]-X</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-14T11:57:06.000Z" title="2021-4-14 7:57:06 ├F10: PM┤">2021-04-14</time>发表</span><span class="level-item"><time dateTime="2021-04-14T12:16:08.531Z" title="2021-4-14 8:16:08 ├F10: PM┤">2021-04-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">4 分钟读完 (大约535个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/14/20210414-redis/">Redis发布订阅</a></h1><div class="content"><p>Redis发布订阅(pub/sub)是一种消息通信模式: 发送者(pub)发送消息,订阅者(sub)接收消息。微信、微博、关注系统!</p>
<p>Redis客户端可以订阅任意数量的频道。</p>
<p>订阅/发布消息图:</p>
<p><img src="/../images/20210414-redis/image-20210414200146898.png" alt="image-20210414200146898"></p>
<p>下图展示了频道channel1，以及订阅这个频道的三个客户端- - client2 、client5 和client1之间的关系:</p>
<p><img src="/../images/20210414-redis/image-20210414200536961.png" alt="image-20210414200536961"></p>
<p>当有新消息通过PUBLISH命令发送给频道channel1时,这个消息就会被发送给订阅它的三个客户端:</p>
<p><img src="/../images/20210414-redis/image-20210414200559801.png" alt="image-20210414200559801"></p>
<blockquote>
<p>命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscribe 频道 <span class="comment"># 订阅频道</span></span><br><span class="line">publish 频道 <span class="comment"># 发布消息到频道</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p>Redis是使用C实现的,通过分析Redis 源码里的pubsub.c文件,了解发布和订阅机制的底层实现,籍此加深对Redis的理解。</p>
<p>Redis通过PUBLISH、SUBSCRIBE 和PSUBSCRIBE等命令实现发布和订阅功能。</p>
<p>通过SUBSCRIBE命令订阅某频道后, redis-server 里维护了一个字典,字典的键就是一个个频道! , 而字典的值则是一个链表,链表中保存了所有订阅这个channel的客户端。SUBSCRIBE 命令的关键,就是将客户端添加到给定channel的订阅链表中。</p>
<p>通过PUBLISH命令向订阅者发送消息, redis-server会使用给定的频道作为键,在它所维护的channel 字典中查找记录了订阅这个频道的所有客户端的链表,遍历这个链表。将消息发布给所有订阅者。</p>
<p>Pub/Sub从字面上理解就是发布( Publish )与订阅( Subscribe ) , 在Redis中,你可以设定对某- -个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后,所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系<br>统,比如普通的即时聊天,群聊等功能。</p>
<p><strong>使用场景：</strong></p>
<p>1、实时消息系统</p>
<p>2、实时聊天室</p>
<p>3、订阅、关注系统</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T09:23:06.000Z" title="2021-4-12 5:23:06 ├F10: PM┤">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-14T11:55:54.769Z" title="2021-4-14 7:55:54 ├F10: PM┤">2021-04-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">8 分钟读完 (大约1231个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/redis/">Redis持久化</a></h1><div class="content"><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><img src="/images/redis/image-20210412160250046.png" alt="image-20210412160250046"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,它恢复时是将快照文件直接读到内存里。</p>
<p>Redis会单独创建( fork ) -个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。整个过程中,主进程是不进行任何I0操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感,那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<p>==RDB 保存的是 xxx.rdb文件==</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<p>1、save的规则自动触发</p>
<p>2、执行flushall</p>
<p>3、退出redis</p>
<p>优点：</p>
<p>1、适合大规模的数据恢复！</p>
<p>2、对数据的完整性不高！</p>
<p>缺点：</p>
<p>1、需要一定时间的间隔！如果redis意外宏碁，最后一次修改的数据就没了</p>
<p>2、fork进程会占用内存空间</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF（append only file）</p>
<p>将所有命令都记录下来，history，恢复的时候将所有命令执行一遍</p>
<p><img src="/images/redis/image-20210412202637273.png" alt="image-20210412202637273"></p>
<p>以日志的形式来记录每个写操作,将Redis执行过的所有指令记录下来(读操作不记录) , 只许追加文件但不可以改写文件, redis启动之初会读取该文件重新构建数据,换言之, redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p>Aof保存的是  xxx.aof文件</p>
<p>aof 文件有错误，redis是启动不起来的，需要使用<code>redis-check-aof  --fix</code>  命令修复</p>
<p>优点：</p>
<p>1、每一次修改都同步，文件的完整性会更加好</p>
<p>2、每秒同步一次，可能会丢失一秒的数据</p>
<p>3、从不同步，效率最高的</p>
<p>缺点：</p>
<p>1、相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢</p>
<p>2、aof运行效率也要比rdb慢，所以redis默认的配置就是rdb持久化</p>
<p>扩展：</p>
<p>1、RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储<br>2、AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, AOF命令以Redis协议追加保存每次写的操作到文件末尾, Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。<br>3、只做缓存,如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化<br>4、同时开启两种持久化方式</p>
<ul>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?作者建议不要,因为RDB更适合用于备份数据库( AOF在不断变化不好备份) , 快速重启,而且AOF可能潜在的Bug ,留着作为一个万一的手段。</li>
</ul>
<p>5、性能建议</p>
<ul>
<li>因为RDB文件只用作后备用途,建议只在Slave.上持久化RDB文件,而且只要15分钟备份一次就够了,只保留save 900 1这条规则。</li>
<li>如果Enable AOF , 好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了,代价一是带来 了持续的I0 ,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少AOF rewrite的频率, AOF重写的基础大小默认值64M太小了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF , 仅靠Master-Slave Repllcation实现高可用性也可以,能省掉一大笔I0 ,也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉,会丢失十几分钟的数据,启动脚本也要比较两个Master/Slave中的RDB文件,载入较新的那个,微博就是这种架构。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-08T12:17:06.000Z" title="2021-4-8 8:17:06 ├F10: PM┤">2021-04-08</time>发表</span><span class="level-item"><time dateTime="2021-04-12T07:48:29.181Z" title="2021-4-12 3:48:29 ├F10: PM┤">2021-04-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">10 分钟读完 (大约1527个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/08/2021-04-08-Redis%E5%85%A5%E9%97%A8/">Redis入门</a></h1><div class="content"><h1 id="Redis-入门"><a href="#Redis-入门" class="headerlink" title="Redis 入门"></a>Redis 入门</h1><p><strong>Redis为什么单线程还这么快？</strong></p>
<p>核心：redis是将所有数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（cpu上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案！</p>
<h3 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h3><p>redis-key、String、List、Set、Hash、Zset</p>
<h6 id="String-（字符串）"><a href="#String-（字符串）" class="headerlink" title="String （字符串）"></a>String （字符串）</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">命令：</span><br><span class="line">append（追加字符串，如果不存在添加）</span><br><span class="line">strlen（字符串长度）</span><br><span class="line">incrby key （自增+1）</span><br><span class="line">incrby key  n（制定增量）</span><br><span class="line"><span class="comment"># 字符串范围 range</span></span><br><span class="line">getrange key 0 3 (字符串截取)</span><br><span class="line">getrange key 0 -1 (全部字符串)</span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">setrange key 1 xx （替换指定位置开始的字符串）</span><br><span class="line">ttl key <span class="comment"># 查看key过期时间</span></span><br><span class="line">setex （<span class="built_in">set</span> with expire） <span class="comment"># 设置过期时间</span></span><br><span class="line">setnx (<span class="built_in">set</span> <span class="keyword">if</span> not exist) <span class="comment"># 不存在再设置（在分布式锁中常使用） key存在失败</span></span><br><span class="line">mset <span class="comment"># 批量添加</span></span><br><span class="line">mget <span class="comment"># 批量获取</span></span><br><span class="line">msetnx <span class="comment"># 原子性操作，要么一起成功要么一起失败</span></span><br><span class="line">getset <span class="comment">#先get再set 如果不存在返回（nil） 如果存在返回原来的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h6><p>可以把list玩成栈、队列、阻塞队列</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lpush list <span class="string">&quot;&quot;</span> <span class="comment"># 添加单个</span></span><br><span class="line">lrange list 0 1 <span class="comment"># 获取list 范围</span></span><br><span class="line">rpush list <span class="string">&quot;&quot;</span> <span class="comment"># 将一个或多个插入到列表尾部</span></span><br><span class="line">lpop list <span class="comment"># 移除 list第一个元素</span></span><br><span class="line">rpop list <span class="comment"># 移除list最后一个元素</span></span><br><span class="line">lindex list 1 <span class="comment"># 通过下标获取元素</span></span><br><span class="line">llen list <span class="comment"># 返回list 长度</span></span><br><span class="line">lrem list n xxx <span class="comment"># 移除一个或多个xxx</span></span><br><span class="line">trim list 1 2 <span class="comment">#截断list</span></span><br><span class="line">rpoplpush list newlist <span class="comment">#移除列表最后一个元素到新列表中</span></span><br><span class="line">lset list 0 xxx <span class="comment"># 将列表中指定下标的值替换为另一个值，如果不存在列表报错，如果存在更新当前下标的值，如果不存在，则会报错</span></span><br><span class="line">linsert list after xx xxx <span class="comment">#将某个具体的value插入到某个元素前面或后面</span></span><br></pre></td></tr></table></figure>

<h6 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sadd key <span class="string">&quot;&quot;</span> <span class="comment"># set集合添加元素</span></span><br><span class="line">smembers key <span class="comment"># 查看指定set的所有值</span></span><br><span class="line">sismember key xxx <span class="comment"># 判断一个元素在set集合中</span></span><br><span class="line">scard key <span class="comment"># 获取set集合中个数</span></span><br><span class="line">srem key xxx <span class="comment"># 移除set中指定元素</span></span><br><span class="line">srandmember key <span class="comment"># 随机抽选一个元素</span></span><br><span class="line">spop key <span class="comment"># 随机删除一个元素</span></span><br><span class="line">smove key1 key2 <span class="string">&quot;xxx&quot;</span> <span class="comment"># 将指定一个元素移动到另一个set中</span></span><br><span class="line">sdiff key1 key2 <span class="comment"># 差集</span></span><br><span class="line">sinter key1 key2 <span class="comment"># 交集 共同好友就可以这样实现</span></span><br><span class="line">sunion key1 key2 <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>

<h6 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h6><p>map集合，key-map </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hset <span class="comment"># 添加一个key-value</span></span><br><span class="line">hget <span class="comment"># 获取一个字段</span></span><br><span class="line">hmset <span class="comment"># 添加多个字段</span></span><br><span class="line">hmget <span class="comment"># 获取多个字段</span></span><br><span class="line">hgetall <span class="comment"># 获取全部数据</span></span><br><span class="line">gdel  <span class="comment"># 删除指定元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>hash存储变更的数据，尤其是用户信息之类的，经常变动的信息！ hash更适合于对象的存储</p>
<h6 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h6><p>在set基础上，增加了一个值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zadd key 1 xxx <span class="comment"># 添加一个值</span></span><br><span class="line">zadd key 2 xxx  3 xxx <span class="comment">#添加多个值</span></span><br><span class="line">zrange key 0 -1 <span class="comment"># 获取所有</span></span><br><span class="line">zrangebyscore key -inf +inf <span class="comment">#从最近到最大 升序排序</span></span><br><span class="line">zrangebyscore key -inf +inf withscores <span class="comment">#显示全部以及附加值</span></span><br><span class="line">zrevrange key 0 -1 <span class="comment"># 从大到小排序</span></span><br><span class="line">zcount key min max <span class="comment"># 获取指定区间数量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例思路: </p>
<p>set排序存储班级成绩表,工资表排序!</p>
<p>普通消息，1，重要消息2 ,带权重进行判断!</p>
<p>排行榜应用实现,取Top N测试!</p>
<h3 id="三种特殊类型"><a href="#三种特殊类型" class="headerlink" title="三种特殊类型"></a>三种特殊类型</h3><p>geospatial（地理空间）、hyperloglogs、bitmaps</p>
<h6 id="geospatial（地理空间）"><a href="#geospatial（地理空间）" class="headerlink" title="geospatial（地理空间）"></a>geospatial（地理空间）</h6><p>朋友的定位，附件的人，打车距离计算</p>
<p>GEO 底层是Zset</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">geoadd key 经度 纬度 地名 <span class="comment"># 添加地理坐标</span></span><br><span class="line">geopos key 地名 <span class="comment"># 获取指定的定位</span></span><br><span class="line">geodist key 地名 地名 单位 <span class="comment"># 直线距离</span></span><br><span class="line">georadius key 经度 纬度 半径 单位 <span class="comment"># 附件的位置</span></span><br><span class="line">georadius key 经度 纬度 半径 单位  withdist <span class="comment"># 显示到中间距离的位置</span></span><br><span class="line">georadius key 经度 纬度 半径 单位  withcoord <span class="comment"># 显示他人的定位信息</span></span><br><span class="line">georadius key 经度 纬度 半径 单位  withcoord count 数量 <span class="comment"># 筛选出指定数量的结果</span></span><br><span class="line">geooradiusbymember key 地名 距离 单位 <span class="comment">#找出位于指定元素周围的其他元素</span></span><br><span class="line">geohash key 地名 地名 <span class="comment"># 将二维的经纬度转为一维字符串，如果俩字符串越接近，那么距离越近</span></span><br></pre></td></tr></table></figure>

<h6 id="hyperloglogs（基础统计）"><a href="#hyperloglogs（基础统计）" class="headerlink" title="hyperloglogs（基础统计）"></a>hyperloglogs（基础统计）</h6><p>hyperloglogs 基础统计的算法 0.81%错误率</p>
<p>基数：不重复的元素</p>
<p>优点：占用内存是固定的</p>
<p>案列：网页浏览量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd key xx <span class="comment"># 创建第一组元素</span></span><br><span class="line">pfcount key <span class="comment">#统计key元素基础数量</span></span><br><span class="line">pfmerge newkey oldkey oldkey <span class="comment"># 合并俩组key 并集</span></span><br></pre></td></tr></table></figure>

<h6 id="bitmaps（位存储）"><a href="#bitmaps（位存储）" class="headerlink" title="bitmaps（位存储）"></a>bitmaps（位存储）</h6><p>统计用户信息，活跃，不活跃！ 登录，未登录！打卡记录！ 俩个状态都可以使用！</p>
<p>操作二进制进行记录 只有0和1 俩状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setbit key 索引 0或1 <span class="comment"># 添加</span></span><br><span class="line">getbit key 索引 <span class="comment"># 查看</span></span><br><span class="line">bitcount key <span class="comment"># 统计</span></span><br></pre></td></tr></table></figure>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis事务本质: 一组命令的集合! -个事务中的所有命令都会被序列化,在事务执行过程的中,会按照顺序执行!</p>
<p>一次性、顺序性、排他性!执行一些列的命令!</p>
<p>redis事务没有隔离级别概念！</p>
<p>Redis单条命令式保存原子性的,但是事务不保证原子性!</p>
<p>redis的事务：</p>
<ul>
<li>开启事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi <span class="comment">#开始事务</span></span><br><span class="line">xxx</span><br><span class="line">xxx</span><br><span class="line"><span class="built_in">exec</span> <span class="comment"># 执行事务</span></span><br><span class="line">discard <span class="comment">#放弃事务</span></span><br></pre></td></tr></table></figure>

<p>编译异常：事务中所有命令都不会被执行，比如命令错误</p>
<p>运行时异常：如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常</p>
<p>监视事务（乐观锁）：如果监视的key在执行事务时候被改变，事务会执行失败</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch xxx  <span class="comment"># 加锁</span></span><br><span class="line">multi</span><br><span class="line">xxx</span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"></span><br><span class="line">unwatch <span class="comment"># 解锁</span></span><br></pre></td></tr></table></figure>

</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="HSQ"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">HSQ</p><p class="is-size-6 is-block">软件开发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京市</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/AHSQ"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="邮箱" href="mailto:hsq0608@gmail.com"><i class="fa fa-envelope-open"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="http://wpa.qq.com/msgrd?v=3&amp;uin=905319761&amp;site=qq&amp;menu=yes"><i class="fab fa-qq"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://blog.csdn.net/qq_34158598" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">本人CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/IDEA%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">IDEA模板</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JUC/"><span class="level-start"><span class="level-item">JUC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Ubuntu/"><span class="level-start"><span class="level-item">Ubuntu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-02T08:46:37.000Z">2021-07-02</time></p><p class="title"><a href="/2021/07/02/idea-template/">IDEA模板</a></p><p class="categories"><a href="/categories/IDEA%E6%A8%A1%E6%9D%BF/">IDEA模板</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-17T06:23:37.000Z">2021-06-17</time></p><p class="title"><a href="/2021/06/17/jvm-20210617/">JVM参数调优</a></p><p class="categories"><a href="/categories/JVM/">JVM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-06-04T06:06:37.000Z">2021-06-04</time></p><p class="title"><a href="/2021/06/04/JUC-20210604/">JUC并发编程</a></p><p class="categories"><a href="/categories/JUC/">JUC</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T11:06:37.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/20210421jvm/">JVM探究</a></p><p class="categories"><a href="/categories/JVM/">JVM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-21T11:06:37.000Z">2021-04-21</time></p><p class="title"><a href="/2021/04/21/Ubuntu-nfs/">Ubuntu安装nfs（服务端）</a></p><p class="categories"><a href="/categories/Ubuntu/">Ubuntu</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AOF/"><span class="tag">AOF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IDEA%E6%A8%A1%E6%9D%BF/"><span class="tag">IDEA模板</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JUC/"><span class="tag">JUC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RDB/"><span class="tag">RDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nfs-Ubuntu/"><span class="tag">nfs Ubuntu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">3</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5936870219195046" data-ad-slot="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2021 HSQ</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>